WEB APPLICATION MODULE REPORT – PERSONAL FINANCE MANAGER
(Website / Web Dashboard Part Only)

-------------------------------------------------------------------------------
1. INTRODUCTION TO THE WEB APPLICATION
-------------------------------------------------------------------------------

The web component of the Personal Finance Manager project is designed as an
interactive dashboard that allows users to input their financial details,
visualize their spending patterns, and receive intelligent recommendations in
real time. While the overall project contains additional modules (such as data
collection, model training, and documentation), this report focuses only on the
website / web interface portion.

The main objective of the website is to make complex financial analysis simple
and easy to understand for normal users. Instead of manually calculating
savings, budgets, and risk levels, users can directly use the webpage, enter
their details, and immediately see charts, warnings, and personalized
recommendations generated by the backend ML logic.

Key design goals for the website:
- Simple and clean UI for non-technical users
- Real-time feedback while entering expenses
- Clear separation between input, output, charts, and recommendations
- Mobile-friendly layout as much as possible
- Professional look suitable for academic project demonstration


-------------------------------------------------------------------------------
2. OVERALL ARCHITECTURE OF THE WEBPAGE
-------------------------------------------------------------------------------

The website is built using a classic three-layer architecture:

1) Frontend (Client-Side):
   - Technologies: HTML5, CSS3, JavaScript
   - Location in project: `templates/` and `static/`
   - Role: Collect user input, show charts, render recommendations, provide
     real-time warnings for overspending and invalid data.

2) Backend (Server-Side):
   - Technology: Python (Flask) + Jupyter Notebook
   - Main entry file: `app.py`
   - Role: Receive user data via HTTP POST, execute the pre-trained models in
     the notebook (`Finance_data_web.ipynb`), generate predictions and
     recommendations, and return a JSON response to the frontend.

3) Data & ML Models:
   - Dataset: `finance_data.csv`
   - Notebook: `Finance_data_web.ipynb`
   - ML Models: Gradient Boosting Regressor for savings prediction and Random
     Forest Classifier for overspending risk.

The user interacts only with the webpage. All heavy computation (ML
prediction, rule-based recommendation generation, and city-tier based
threshold calculations) happens on the server, and the results are rendered
back to the browser through JavaScript.


-------------------------------------------------------------------------------
3. FRONTEND IMPLEMENTATION (HTML + CSS + JAVASCRIPT)
-------------------------------------------------------------------------------

3.1 HTML STRUCTURE (TEMPLATES)

The main HTML pages are stored in the `templates/` folder:
- `index.html`  – Landing/dashboard page
- `input.html`  – (If used separately) input-focused page for form entry

Major sections of the main page:
- Header / Title area: Shows project title and brief subtitle
- Input Form Section: Allows the user to enter income, age, dependents,
  occupation, city tier, and detailed expense categories (Rent, Groceries,
  Transport, Eating Out, Entertainment, Utilities, Healthcare, Education,
  Miscellaneous, etc.)
- Real-Time Warnings Panel: Inline messages below each expense field
- Charts / Visualization Section: Displays interactive graphs for expenses,
  income vs expenses, savings projections, and correlations
- Insights & Recommendations Section: Shows text-based insights, bullet-point
  recommendations, and city-tier specific advice

[SCREENSHOT PLACEHOLDER – HOME / DASHBOARD LAYOUT]
("Screenshot 1: Overall dashboard layout showing input form on the left and
charts + recommendations on the right.")


3.2 STYLING AND RESPONSIVE DESIGN (CSS)

All styling is done in `static/css/style.css`. The main focus points were:
- Use of a clean, modern color palette suitable for financial data (blues,
  greens, and subtle greys)
- Card-based layout for forms, charts, and recommendation areas
- Visual emphasis on important numbers (income, predicted savings, risk
  level) using larger fonts and highlighting
- Status indicators with colors (e.g., red/yellow/green tags for expense
  status and overspending risk)
- Basic responsiveness so that the dashboard is usable on different screen
  sizes (laptops and tablets)

CSS is also used to animate warning messages (such as fade-in effect) when the
user overspends in a category. This makes the UI feel more dynamic and
professional during demonstration.

[SCREENSHOT PLACEHOLDER – STYLED INPUT FORM]
("Screenshot 2: Input form design with labeled fields and styled submit
button.")


3.3 CLIENT-SIDE LOGIC (JAVASCRIPT)

The JavaScript logic is implemented in `static/js/script.js`. The major
client-side features are:

1) Form Handling and Validation:
   - Captures all input values from the form fields.
   - Performs basic checks (e.g., non-negative values, non-empty income).
   - Calculates `Total_Expenses` on the fly as the user types.

2) Real-Time Expense Warnings:
   - For each category (Rent, Groceries, Transport, Eating Out, etc.),
     JavaScript checks whether the amount is within the recommended
     percentage for the selected city tier.
   - If the user is overspending, the script shows a message like:
     "High spending on Eating Out – consider reducing frequency of
      restaurant visits." and highlights the field.
   - These warnings appear immediately without reloading the page.

3) AJAX/Fetch Call to Backend:
   - On form submission, JavaScript sends a POST request to the Flask backend
     with all user inputs as JSON.
   - It then waits for the JSON response from the server which contains:
     - Predicted savings
     - Overspend probability
     - Generated insights
     - Recommendation lines
     - Expense breakdown by category
     - Chart data (arrays for income, expenses, months, etc.)

4) Rendering Recommendations and Insights:
   - The response from the server contains recommendation text as an array
     of lines.
   - The script groups and formats these lines into structured bullet points
     and sections for better readability.

5) Plotting Charts with Plotly:
   - The script uses Plotly.js to render:
     - Scatter Plot (Income vs Total Expenses with city tier colors)
     - Pie Chart (Average expense breakdown)
     - Bar Chart (Expenses by occupation or category)
     - Line Chart (Predicted savings projection over 12 months)
     - Heatmap (Correlation between income, expenses, savings, etc.)

[SCREENSHOT PLACEHOLDER – REAL-TIME WARNING]
("Screenshot 3: Example of a red/yellow warning shown below an expense field
when the user overspends in that category.")

[SCREENSHOT PLACEHOLDER – CHARTS SECTION]
("Screenshot 4: Multiple Plotly charts rendered on the dashboard showing
expense distribution and savings projection.")


-------------------------------------------------------------------------------
4. BACKEND INTEGRATION (FLASK + NOTEBOOK)
-------------------------------------------------------------------------------

4.1 FLASK APPLICATION (`app.py`)

The Flask app acts as the bridge between the web frontend and the machine
learning logic. Its main responsibilities are:
- Serve the main HTML templates when the user visits the website
- Receive form data via POST requests (usually as JSON)
- Prepare the payload for the Jupyter notebook
- Execute the notebook logic (or directly call functions imported from it)
- Return a JSON response containing predictions, charts, insights, and
  recommendations

Typical flow inside `app.py`:
1) User submits the form on the webpage.
2) JavaScript sends the data to a Flask route, e.g. `/predict`.
3) Flask normalizes the data, sets an environment variable, or directly calls
   `run_user_prediction(...)` defined in the notebook code.
4) The notebook logic computes predictions and writes `user_prediction.json`.
5) Flask reads the results and sends them back to the browser.


4.2 NOTEBOOK LOGIC (`Finance_data_web.ipynb`)

Although this report is focused on the webpage, the notebook is tightly
connected to the web interface. The website part uses the following notebook
functions:
- Normalization of user input
- Training/loaded ML models (savings predictor, overspend risk classifier)
- Category-wise analysis function
- Recommendation generator (8 major sections of advice)
- Chart data generator

The important point is that the web frontend does not itself implement the
financial logic – it delegates calculations to the backend, which ensures that
any future changes to the financial model can be done on the Python side
without redesigning the whole UI.

[SCREENSHOT PLACEHOLDER – API CALL FLOW]
("Screenshot 5: Diagram or screenshot explaining how the browser, Flask app,
notebook, and JSON responses interact.")


-------------------------------------------------------------------------------
5. KEY FEATURES IMPLEMENTED IN THE WEBSITE
-------------------------------------------------------------------------------

This section lists the main features that have been implemented in the web
module of the project. Only web-related features are mentioned here.

5.1 User-Friendly Input Form
- Structured form where the user can enter all relevant data:
  Income, Age, Dependents, Occupation, City Tier, and a detailed list of
  monthly expenses across 11 categories.
- Clear labels and units (₹ for rupees) to avoid confusion.
- Default or sample values can be pre-filled for quick demo.


5.2 Real-Time Expense Monitoring and Warnings
- As the user types in each category amount, client-side JavaScript compares
  it against recommended thresholds that depend on the chosen city tier.
- Color-coded messages and subtle animations help the user see which
  categories are overshooting reasonable limits.
- This gives immediate feedback even before any server call or ML
  computation.


5.3 Integration with Machine Learning Models
- The submit action sends data to the backend, where ML models predict:
  - How much the user can realistically save per month
  - Probability that the user will overspend (overspend risk)
- The updated predictions are shown on the same page without manual
  recalculation by the user.


5.4 Comprehensive Recommendation Section
- The webpage displays a long, structured recommendation block divided into
  multiple sections such as:
  - Expense Optimization Strategy
  - Investment & Wealth Building
  - Insurance & Risk Protection
  - Debt Optimization Strategy
  - Emergency Fund & Liquidity
  - Tax Saving Opportunities
  - Quick Wins for the specific City Tier
  - High-Risk Mitigation (if overspend probability is high)
- Within each section, the content is rendered as bullet points and
  sub-points for clarity.

[SCREENSHOT PLACEHOLDER – RECOMMENDATION SECTION]
("Screenshot 6: Scrollable recommendations area showing different sections and
bullet points.")


5.5 Visual Analytics and Interactive Charts
- The dashboard includes multiple interactive charts:
  1. Scatter plot showing Income vs Total Expenses with city-wise coloring
  2. Pie chart of expense distribution across categories
  3. Bar chart comparing occupations or categories
  4. Line chart for 12-month savings projection
  5. Heatmap showing correlations between key financial variables
- Users can hover, zoom, and interact with these charts thanks to Plotly.


5.6 City-Tier Aware Behavior
- The website allows the user to select a city tier (Tier 1, Tier 2, or
  Tier 3), which changes recommended expense percentages dynamically.
- Recommendations in the text also adapt. For example, Tier 1 advice focuses
  on metro cities (expensive rent, high transport cost), whereas Tier 3
  advice is optimized for smaller cities.


5.7 Clean and Professional UI
- Use of Unicode symbols instead of emojis in the final text output to keep
  the look professional.
- Removal of unnecessary separator lines and visual clutter so that the
  recommendation text looks neat and organized.
- A layout suitable for academic evaluation and mentor presentation.


-------------------------------------------------------------------------------
6. HOW THE WEBPAGE WORKFLOW OPERATES (STEP-BY-STEP)
-------------------------------------------------------------------------------

1) User opens the main page (`index.html`) from the Flask server.
2) User selects Occupation and City Tier, then fills income and expenses.
3) As each expense is filled, the JavaScript logic:
   - Recalculates total expenses
   - Compares category expenses with recommended limits
   - Shows warning messages where required
4) Once the user is satisfied, they click on the "Analyze" or similar button.
5) JavaScript sends all form data to the Flask backend as a JSON payload.
6) Flask passes this data to the Python logic (from the notebook functions).
7) Backend calculates:
   - Predicted savings
   - Overspend probability
   - Category-wise breakdown and potential savings
   - Multi-section recommendation text
   - Chart data for Plotly
8) Flask sends a single JSON response back to the browser.
9) JavaScript receives the data and updates:
   - Numeric fields (predicted savings, shortfall, risk percentage)
   - Charts (scatter, pie, bar, line, heatmap)
   - Text sections (insights and recommendations)
10) User can scroll through the recommendations, adjust inputs, and run the
    analysis again as many times as needed.

[SCREENSHOT PLACEHOLDER – WORKFLOW DEMO]
("Screenshot 7: Sequence showing form input, click on analyze, and updated
results on the same page.")


-------------------------------------------------------------------------------
7. TESTING AND DEMONSTRATION ASPECTS (WEB MODULE)
-------------------------------------------------------------------------------

For the webpage component, the following basic tests and checks were
performed:
- Form validation: Ensured that negative numbers or empty income values are
  handled gracefully on the frontend.
- Boundary testing: Tried extreme values for expenses (very high and very
  low) to see if warnings and recommendations behave logically.
- City tier switching: Verified that changing the city tier actually changes
  warnings and recommended percentages for rent, transport, food, etc.
- Cross-browser check (basic): Opened the site in at least two browsers to
  confirm layout and script compatibility.

During demonstration to the mentor, the recommended flow is:
1) Show the clean UI layout and explain each section briefly.
2) Enter a realistic salary and typical metro-city expenses.
3) Highlight how real-time warnings appear immediately.
4) Run the full analysis and scroll through charts and recommendations.
5) Change city tier and demonstrate how advice changes.


-------------------------------------------------------------------------------
8. CONCLUSION (WEBPAGE PART ONLY)
-------------------------------------------------------------------------------

The web module of the Personal Finance Manager project successfully bridges
complex backend logic with an easy-to-use user interface. Instead of showing
only static numbers, the webpage:
- Interacts with the user in real time
- Visualizes financial data through interactive charts
- Delivers detailed, city-tier aware recommendations
- Integrates machine learning predictions without exposing any complexity to
  the end user

This component alone can be presented as a complete, modern web dashboard for
personal finance analysis. When combined with the other project modules (data,
model training, and documentation), it forms a strong end-to-end solution. In
this report, only the website related aspects are covered as required
(approximately 5–6 pages in plain text format).
